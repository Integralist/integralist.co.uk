<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>Integralist</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="../../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Main -->
      <div id="main">
        <div class="inner">
          <!-- Header -->
					<header id="header">
						<a href="../../index.html" class="logo"><strong>Home</strong></a>
							<ul class="icons">
							<!--<li><a href="https://x.com/integralist" class="icon brands fa-twitter" target="blank"><span class="label">Twitter</span></a></li>-->
							<!--<li><a href="https://instagram.com/wwfsuperstarsofwrestling" class="icon brands fa-instagram" target="blank"><span class="label">Instagram</span></a></li>-->
						</ul>
					</header>

          <!-- Content -->
          <section>
						<!--
            <header class="main">
              <h1>Royal Rumble 1989</h1>
              <p>A Bizarre Spectacle Where the Madness Multiplies</p>
            </header>
            <span class="image main"><img src="../images/rumble-89.jpg" alt="" /></span>
						-->
						<nav>

<ul>
<li><a href="#host-methods-vs-native-methods">Host Methods vs Native Methods</a>
<ul>
<li><a href="#introduction">Introduction</a></li>

<li><a href="#what-they-are">What they are?</a></li>

<li><a href="#how-to-detect-them">How to detect them?</a></li>

<li><a href="#when-is-it-ok-to-modify-them">When is it OK to modify them?</a></li>
</ul></li>
</ul>

</nav>

<h1 id="host-methods-vs-native-methods">Host Methods vs Native Methods</h1>

<h2 id="introduction">Introduction</h2>

<p>This was intended as a short and overly simplified post about Host methods and Native methods.</p>

<h2 id="what-they-are">What they are?</h2>

<p>Native methods are built-in functions provided by the ECMAScript core specification. So things like Object methods (e.g. <code>Object.create</code>), Array methods (e.g. <code>Array#forEach</code>) etc.</p>

<p>Host methods are functions provided by the host environment (most of the time when working in web development the host environment will be the user’s web browser). So things like the DOM API and the Events object are host objects/methods (e.g. <code>attachEvent</code> is a host method and <code>addEventListener</code> is a host method)</p>

<h2 id="how-to-detect-them">How to detect them?</h2>

<p>Detecting Native methods is relatively straight forward. The real problem comes when you need to determine whether the object/method you’re detecting actually works the way the specification dictates it should work. So just checking it is available to use isn’t good enough.</p>

<p>Detecting host methods is similar but a lot more problematic, because the ECMAScript specification states that the host environment can implement certain methods however they like and so there is no guarantee that your checks for certain host methods (which may work today) will work in future.</p>

<p>We’ll give an example of each so you can get an idea of what I mean…</p>

<p>To detect a Native method such as Array#forEach you should be able to do the following:</p>

<pre><code>if (!Array.prototype.forEach) { 
    /* polyfill for missing forEach method */ 
}
</code></pre>

<p>Note: polyfill is a term that Remy Sharp coined which means ‘a shim that mimics a future API’ (see: <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/" target="_blank">http://remysharp.com/2010/10/08/what-is-a-polyfill/</a>)</p>

<p>But the issue you could encounter in this example is if you’re inheriting a project from another developer and they have already extended the Native Array object with a forEach method and their polyfill version of the missing forEach function doesn’t work how the specification has dictated it should then you could find your code errors at hard to debug stages because of the difference in implementation where you’re passing parameters into a polyfill’ed method and that method hasn’t been implemented properly so the extra parameters either throw an error or (potentially worse) silently fail.</p>

<p>This is where you either ‘suck it and see’ (which is a bad idea, but not always unavoidable), or you attempt genuine ‘feature detection’ which means (in this example) you create a test Array and test the forEach method works how you expect it to.</p>

<p>The downsides to this approach (although it is the most robust and future-proof way of writing your code) is that all these checks are a performance penalty. If you’re sure the method you’re checking for is going to work how you expect it to then should you waste time/effort writing additional checks/tests to ensure the method works how the specification dictates? What happens if you do the full feature detection and discover the method doesn’t work how you expect it? You’ll still then need to implement some kind of fallback or lose the functionality that relies on that method.</p>

<p>These are important decisions that need to be made and ones that are outside the realms of this post I’m afraid (simply because there are no easy answers).</p>

<p>Now, detecting Host methods is actually worse because they can be implemented in any fashion the host environment chooses.</p>

<p>So far it has been <em>noted</em> that checking the <code>typeof</code> result for a Host method will normally result in either function, object or unknown, so if you get one of these back as a result then it’s a good chance the host object you’re checking for is available to use, but as you should be able to tell by now, this is a flawed process… fun heh!</p>

<p>Again, this isn’t a reliable assumption to make, because in a future/new host environment they might have a <code>typeof</code> result that is none of the above. Literally you could check the <code>typeof</code> for a method and its result could be <em>spacecraft</em> - there are no rules as far as the Host environment is concerned!</p>

<p>But for testing a host method exists, the following function has become the de-facto standard:</p>

<pre><code>/*
 * Feature Testing a Host Method
 * Because a callable host object can legitimately have any typeof result then it can't be relied upon.
 *
 * @notes:
 * The reason for the &amp;&amp; !!object[property] is because in ECMAScript version 3, 
 * a null object has typeof result 'object' (which is considered a bug).
 * In future versions (ECMAScript 6+) the typeof result will be 'null' (as it should be).
 * 
 * @reference: http://michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
 */

function isHostMethod(object, property) {
    var type = typeof object[property];

    return type == 'function' || // This is the result we're expecting (as the test is for a method)
           (type == 'object' &amp;&amp; !!object[property]) || // Protect against ES3 'null' typeof result being 'object'
           type == 'unknown'; // For IE &lt; 9 when Microsoft used ActiveX objects for Native Functions (we're checking property of ActiveX object)
}
</code></pre>

<p>So lets take a quick re-cap of what’s going on here:</p>

<ul>
<li><p><code>function</code>:<br>
For most browsers the <code>typeof</code> operator will result with <code>function</code> when passed a callable host object</p></li>

<li><p><code>'object’ &amp;&amp; !!object[property]</code>:<br>
Because we&rsquo;re dealing with host objects we can&rsquo;t expect <code>function</code> to be returned, and in most cases (as far as ECMAScript 3 [ES3] implementations are concerned) the result will normally be <code>object</code> which is incorrect but allowed as far as the ES3 spec is concerned.</p></li>
</ul>

<p>So first of all we check for <code>object</code>.</p>

<p>If that matches we then check to make sure the property coerces to true. The reason for this is that ES3 allows the host to return whatever they like, so if the property you&rsquo;re checking for is actually <code>null</code> the ES3 <code>typeof</code> result (for most browsers) will still be <code>object</code> even though the result is <code>null</code>! So to work around this issue we coerce the result into a boolean (so if <code>null</code> is the result it will coerce to false and thus this whole expression will return false, otherwise it&rsquo;ll return true).</p>

<ul>
<li><code>unknown</code>:<br>
In older versions of IE (less than 9) it implements some of its host objects not as Native functions but as ActiveX objects (admittedly this is deep browser implementation talk and normally you don’t need to know this stuff, but in this instance it’s important to understand what the heck is going on with IE).</li>
</ul>

<p>So, in IE calling the <code>typeof</code> operator with properties of an ActiveX Object will result in <code>unknown</code>.</p>

<h2 id="when-is-it-ok-to-modify-them">When is it OK to modify them?</h2>

<p>Modifying built-in Native objects isn’t as dangerous as host objects (as already noted by Kangax <a href="http://perfectionkills.com/extending-built-in-native-objects-evil-or-not/" target="_blank">http://perfectionkills.com/extending-built-in-native-objects-evil-or-not/</a>) but care needs to be taken to ensure the augmented object works as the spec dictates (something that isn’t possible all the time, for example like with <code>Object.create</code>).</p>

<p>As far as host objects are concerned, never ever ever ever modify or augment them, just too dangerous.</p>

          </section>
        </div>
      </div>
      <!-- Sidebar -->
<div id="sidebar">
  <div class="inner">
    <!-- Search -->
    <!--<section id="search" class="alt">-->
    <!--  <form method="post" action="#">-->
    <!--    <input type="text" name="query" id="query" placeholder="Search" />-->
    <!--  </form>-->
    <!--</section>-->
    <!-- Menu -->
    <nav id="menu">
      <header class="major">
        <h2>Menu</h2>
      </header>
      <ul>
        <li><a href="../../index.html">About</a></li>
        <!--<li><a href="../resume/index.html">Resume</a></li>-->
				
      </ul>
    </nav>
    <!-- Section -->
		<!--
    <section>
      <header class="major">
        <h2>Highlights</h2>
      </header>
      <div class="mini-posts">
        <article>
          <a href="ppv-survivorseries-88.html" class="image"><img src="../images/survivor-88-index.jpg" alt="" /></a>
          <p>Get ready for the ultimate showdown as Survivor Series 1988 brings non-stop tag team action, fierce rivalries, and unforgettable battles between the biggest WWF superstars!</p>
        </article>
        <article>
          <a href="ppv-royalrumble-89.html" class="image"><img src="../images/rumble-89-index.jpg" alt="" /></a>
          <p>Royal Rumble 1989 unleashes chaos with 30 superstars battling for glory in an unforgettable over-the-top-rope showdown!</p>
        </article>
        <article>
          <a href="ppv-summerslam-88.html" class="image"><img src="../images/slam-88-index.jpg" alt="" /></a>
          <p>SummerSlam 1988 delivers explosive action with iconic matchups, as the WWF's biggest stars collide in the hottest event of the summer!</p>
        </article>
      </div>
    </section>
		-->
    <!-- Section -->
    <!--<section>-->
    <!--  <header class="major">-->
    <!--    <h2>Get in touch</h2>-->
    <!--  </header>-->
    <!--  <p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus, ac varius enim lorem ullamcorper dolore. Proin sed aliquam facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p>-->
    <!--  <ul class="contact">-->
    <!--    <li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li>-->
    <!--    <li class="icon solid fa-phone">(000) 000-0000</li>-->
    <!--    <li class="icon solid fa-home">1234 Somewhere Road #8254<br />-->
    <!--      Nashville, TN 00000-0000</li>-->
    <!--  </ul>-->
    <!--</section>-->
    <!-- Footer -->
    <footer id="footer">
      <p class="copyright">&copy; Integralist. All rights reserved.</p>
      <p class="copyright small">Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>
  </div>
</div>

    </div>
    <!-- Scripts -->
    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/browser.min.js"></script>
    <script src="../../assets/js/breakpoints.min.js"></script>
    <script src="../../assets/js/util.js"></script>
    <script src="../../assets/js/main.js"></script>

		<!-- The following script is for handling the automatic TOC generated by `make build` -->
		<script>
		// Get references to the elements
		const nav = document.querySelector('#main nav');
		const h1 = document.querySelector('#main h1');

		// Move the `nav` element to be underneath the `h1`
		h1.insertAdjacentElement('afterend', nav);

		// Hide the `nav` element by default using inline styles
		nav.style.display = 'none';

		// Create a new `h2` element with the text "TOC"
		const toc = document.createElement('h2');
		toc.textContent = 'TOC';
		toc.className = "toc"

		// Add inline styles to make the `h2` look clickable
		// DISABLED: done with className
		//
		// toc.style.cursor = 'pointer';
		// toc.style.color = 'blue';
		// toc.style.textDecoration = 'underline';

		// Add a click event listener to toggle the visibility of the `nav`
		toc.addEventListener('click', () => {
				nav.style.display = nav.style.display === 'none' ? 'block' : 'none';
		});

		// Insert the `h2` element above the `nav`
		nav.insertAdjacentElement('beforebegin', toc);
		</script>
  </body>
</html>
