<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
  <head>
    <title>Integralist</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="../../assets/css/main.css" />
  </head>
  <body class="is-preload">
    <!-- Wrapper -->
    <div id="wrapper">
      <!-- Main -->
      <div id="main">
        <div class="inner">
          <!-- Header -->
					<header id="header">
						<a href="../../index.html" class="logo"><strong>Home</strong></a>
							<ul class="icons">
							<!--<li><a href="https://x.com/integralist" class="icon brands fa-twitter" target="blank"><span class="label">Twitter</span></a></li>-->
							<!--<li><a href="https://instagram.com/wwfsuperstarsofwrestling" class="icon brands fa-instagram" target="blank"><span class="label">Instagram</span></a></li>-->
						</ul>
					</header>

          <!-- Content -->
          <section>
						<!--
            <header class="main">
              <h1>Royal Rumble 1989</h1>
              <p>A Bizarre Spectacle Where the Madness Multiplies</p>
            </header>
            <span class="image main"><img src="../images/rumble-89.jpg" alt="" /></span>
						-->
						<nav>

<ul>
<li><a href="#rate-limiting-at-the-cdn-edge">Rate Limiting at the CDN Edge</a>
<ul>
<li><a href="#what-is-rate-limiting">What is Rate Limiting?</a></li>

<li><a href="#problems-with-rate-limiting">Problems with Rate Limiting</a>
<ul>
<li><a href="#identify-clients-more-granularly">Identify clients more granularly</a></li>

<li><a href="#get-your-cdn-to-help">Get your CDN to help</a></li>
</ul></li>

<li><a href="#architecture">Architecture</a></li>

<li><a href="#downsides">Downsides</a></li>

<li><a href="#features">Features</a></li>

<li><a href="#example-code">Example Code</a></li>
</ul></li>
</ul>

</nav>

<h1 id="rate-limiting-at-the-cdn-edge">Rate Limiting at the CDN Edge</h1>

<h2 id="what-is-rate-limiting">What is Rate Limiting?</h2>

<p>Rate Limiting is a technique used to control the rate of requests received.</p>

<p>It exists to help online services to stay up and running even when clients of the service are issuing lots of requests.</p>

<p>Think of an API such as the <a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting" target="_blank">GitHub API</a>. If they didn&rsquo;t rate limit their clients, then it&rsquo;s very possible a single client could consume most of their resources (either accidentally or intentionally, i.e. a &ldquo;bad actor&rdquo;).</p>

<h2 id="problems-with-rate-limiting">Problems with Rate Limiting</h2>

<p>There are two key issues that I needed to address for my employer. The first is very specific to the needs we were trying to solve, and the other is a general issue&hellip;</p>

<ol>
<li>our service is public, not private.</li>
<li>avoid overloading our internal infrastructure.</li>
</ol>

<p>Let&rsquo;s consider the first point: most exposed APIs will expect a client to provide a &lsquo;key&rsquo; in order to access the API (this allows the API service to keep a track of individual clients and to ensure they aren&rsquo;t being overly aggressive with their requests).</p>

<p>But I work for a well known online publisher, and so our customers are public users visiting our public website, which means we can&rsquo;t rate limit using a &lsquo;key&rsquo;.</p>

<p>This is because we don&rsquo;t know who our clients are, and so we can&rsquo;t expect them to have signed up to get a key to access our content (unless our content was sat behind a paywall, which it isn&rsquo;t).</p>

<p>This means we have to identify clients another way. The typical approach here is to identify a client by their IP address.</p>

<p>Identifying a client by an IP is problematic for rate limiting because you potentially will end up grouping together multiple clients who all happen to be using the same IP address (e.g. a college campus).</p>

<p>So what can we do to address these two issues?</p>

<ul>
<li><a href="#identify-clients-more-granularly">Identify clients more granularly</a></li>
<li><a href="#get-your-cdn-to-help">Get your CDN to help</a></li>
</ul>

<h3 id="identify-clients-more-granularly">Identify clients more granularly</h3>

<p>The problem with IP identification is that it&rsquo;s not granular enough. To workaround this issue we create a fingerprint of the client that&rsquo;s actually a hash built from multiple contextual pieces of data:</p>

<pre><code>&lt;host&gt;:&lt;path&gt;:&lt;method&gt;:&lt;client-ip&gt;:&lt;user-agent&gt;
</code></pre>

<p>This means we ultimately are rate limiting clients on a &lsquo;path&rsquo; basis, meaning a client can request <code>/foo</code> enough to be rate limited for that path but still be allowed to access <code>/bar</code>.</p>

<p>But this doesn&rsquo;t help us with web scrapers and fuzzers who present a potential Denial of Service (DoS) attack by hitting <em>multiple</em> endpoints at a very high rate (this is because the count for a single path could be low while their overall crawling impact could be much larger and damaging).</p>

<p>This forces us to define two types of clients:</p>

<ol>
<li>Standard</li>
<li>Broad</li>
</ol>

<p>The &lsquo;standard&rsquo; clients are those we described originally (they hit a single endpoint at a high rate). An example of this are pentesters trying to compromise a sign-in page.</p>

<p>The &lsquo;broad&rsquo; clients are those who have a less granular fingerprint (specifically <code>&lt;client-ip&gt;:&lt;user-agent&gt;</code>), and where we cross reference them against a list of known pentesting/scraper/fuzzer tools.</p>

<h3 id="get-your-cdn-to-help">Get your CDN to help</h3>

<p>The problem we had was that our internal services were struggling to handle the volume of uncacheable requests.</p>

<p>What would be better is if we could leverage the scale of our CDN provider (<a href="https://www.fastly.com/" target="_blank">Fastly</a>) rather than have our internal infrastructure front the burden.</p>

<p>To do this we needed a way for the CDN to be able to identify a client as one that should be rate limited. But we didn&rsquo;t have enough programmatic access with Fastly to achieve this (their infrastructure is designed around <a href="https://varnish-cache.org/" target="_blank">Varnish</a> which uses a specialized DSL called <a href="https://book.varnish-software.com/4.0/chapters/VCL_Basics.html" target="_blank">VCL</a>).</p>

<p>I won&rsquo;t explain <em>why</em> we didn&rsquo;t have enough programmatic access with Fastly, because it requires an understanding of Fastly and their services, which is outside the scope of this post.</p>

<blockquote>
<p>Note: Fastly does have a beta product called <a href="https://www.fastly.com/blog/join-the-beta-new-serverless-compute-environment-at-the-edge" target="_blank">compute@edge</a> but it&rsquo;s still very early stages and they don&rsquo;t recommend their customers use it for production workloads.</p>
</blockquote>

<h2 id="architecture">Architecture</h2>

<p>With the above understanding clear in our minds, let&rsquo;s take a look at the architecture I ended up designing/implementing:</p>

<ul>
<li>Existing proxy tracks clients via Redis.</li>
<li>New HTTP service (written in Go):

<ul>
<li>Periodically scans Redis.</li>
<li>Identifies if client should be rate limited.</li>
<li>Updates Fastly &lsquo;edge dictionary&rsquo; via Fastly API.</li>
</ul></li>
<li>Fastly CDN checks &lsquo;edge dictionary&rsquo; and rejects clients as necessary.</li>
</ul>

<p>Visually this looks something like&hellip;</p>

<p><a href="../../assets/images/ratelimit.png">
  <img src="../../assets/images/ratelimit.png" class="post-img" loading="lazy">
</a></p>

<hr>

<p>Two things worth clarifying in the above architecture diagram&hellip;</p>

<ol>
<li>We&rsquo;ll attempt to serve a cached response from the CDN otherwise we&rsquo;ll attempt to serve stale (if available), before finally falling back to a synthetic <code>429 Too Many Requests</code>.</li>
<li>The &ldquo;Perimeter&rdquo; service directly behind the CDN was a pre-existing custom built reverse proxy (only slightly modified for the purpose of putting clients into redis).</li>
</ol>

<h2 id="downsides">Downsides</h2>

<p>The biggest downside is that there is a delay in applying rate limits, as processing data isnâ€™t happening at runtime (i.e. the &lsquo;Rate Control&rsquo; service is decoupled from the perimeter proxy).</p>

<p>This additionally introduces some complexity in the sense that we have to limit requests per &lsquo;minute&rsquo; rather than the more traditional &lsquo;request per second&rsquo; (as we need to allow the external service time to process data).</p>

<p>Subsequently this design will allow more requests through to our internal infrastructure before rate limiting will be applied. In practice this hasn&rsquo;t been an issue for us, but it&rsquo;s worth calling out.</p>

<p>Lastly, although this works well for our purposes I appreciate it is not a perfect solution, and is merely a tourniquet.</p>

<h2 id="features">Features</h2>

<p>OK, so let&rsquo;s review the benefits of this design&hellip;</p>

<ul>
<li>Verifies if a client requires rate limit restriction.

<ul>
<li>Then notifies CDN to action this behaviour.</li>
</ul></li>
<li>Provides DoS level protection.</li>
<li>Implements granular level of client identification.</li>
<li>Supports identification/blocking of common scrapers/fuzzers:

<ul>
<li><a href="http://sqlmap.org" target="_blank">http://sqlmap.org</a></li>
<li><a href="https://scrapy.org" target="_blank">https://scrapy.org</a></li>
<li><a href="https://simplepie.org" target="_blank">https://simplepie.org</a></li>
<li><a href="https://nutch.apache.org" target="_blank">https://nutch.apache.org</a></li>
<li><a href="https://github.com/ffuf/ffuf" target="_blank">https://github.com/ffuf/ffuf</a></li>
<li><a href="https://tools.kali.org/web-applications/wfuzz" target="_blank">https://tools.kali.org/web-applications/wfuzz</a></li>
</ul></li>
<li>Supports reduction of requests handled by our own infrastructure.</li>
<li>Supports reduction of additional latency.</li>
<li>Avoids overloading upstream proxy(s) responsibility.</li>
<li>Provides CLI tooling to:

<ul>
<li>Clear a rate limited client from the Fastly edge dictionary.</li>
<li>Toggle on/off rate limiting at the edge.</li>
</ul></li>
</ul>

<blockquote>
<p>Note: although not done yet, I intend on building an internal UI service for &lsquo;Rate Control&rsquo; that will make interfacing with the various components easier (inc. all features currently present in the CLI).</p>
</blockquote>

<h2 id="example-code">Example Code</h2>

<p>Let&rsquo;s see some example VCL code to understand the CDN edge implementation a bit better&hellip;</p>

<blockquote>
<p>Note: for brevity I&rsquo;ve removed chunks of logic so we can more easily focus in on the &lsquo;control flow&rsquo;.</p>
</blockquote>

<pre><code>sub ratelimit_trigger {
  // client is rate limited, so attempt to find cached version of the content
  //
  set req.http.X-Reject = &quot;true&quot;;
  return(lookup);
}

sub ratelimit_recv {
  // client_key generates a key from the contextual data we're looking for
  //
  set var.client_hash = digest.hash_sha1(var.client_key);

  if (table.lookup(ratelimit, var.client_hash) == &quot;true&quot;) {
    call ratelimit_trigger;
  }

  // if we're unable to find the current key, then before we allow the normal request flow to continue
  // we'll first check if we can find a 'bad actor' (e.g. web scraper/fuzzer) in the rate limit table
  //
  // NOTE: it's at this point we'd change the client_key and regenerate the client_hash.
  //
  if (table.lookup(ratelimit, var.client_hash) == &quot;true&quot;) {
    call ratelimit_trigger;
  }
}

sub ratelimit_miss {
  // we were unable to find cached content, so move to vcl_error
  // where we'll attempt to serve stale if it exists, otherwise
  // we'll serve a synthetic '429 Too Many Requests'
  //
  error 601;
}

sub ratelimit_error {
  if (obj.status == 601) {
    if (stale.exists) {
      return(deliver_stale);
    }

    set obj.status = 429;
    set obj.response = &quot;Too Many Requests&quot;;
    set obj.http.Content-Type = &quot;text/html&quot;;
    synthetic {&quot;&lt;h1&gt;Too Many Requests&lt;/h1&gt;&quot;};
    return(deliver);
  }
}
</code></pre>

<p>The above code would typically be a separate code file which we&rsquo;d include in our standard VCL file and then call within the relevant state subroutines&hellip;</p>

<blockquote>
<p>Note: again I&rsquo;ve omitted chunks of code for the sake of brevity.</p>
</blockquote>

<pre><code>include &quot;rate_limiting&quot;

sub vcl_recv {
  unset req.http.X-Reject;

  call ratelimit_recv;
}

sub vcl_miss {
  if (req.http.X-Reject == &quot;true&quot;) {
    call ratelimit_miss;
  }
}

sub vcl_error {
  call ratelimit_error;
}
</code></pre>

          </section>
        </div>
      </div>
      <!-- Sidebar -->
<div id="sidebar">
  <div class="inner">
    <!-- Search -->
    <!--<section id="search" class="alt">-->
    <!--  <form method="post" action="#">-->
    <!--    <input type="text" name="query" id="query" placeholder="Search" />-->
    <!--  </form>-->
    <!--</section>-->
    <!-- Menu -->
    <nav id="menu">
      <header class="major">
        <h2>Menu</h2>
      </header>
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <!--<li><a href="../resume/index.html">Resume</a></li>-->
				
      </ul>
    </nav>
    <!-- Section -->
		<!--
    <section>
      <header class="major">
        <h2>Highlights</h2>
      </header>
      <div class="mini-posts">
        <article>
          <a href="ppv-survivorseries-88.html" class="image"><img src="../images/survivor-88-index.jpg" alt="" /></a>
          <p>Get ready for the ultimate showdown as Survivor Series 1988 brings non-stop tag team action, fierce rivalries, and unforgettable battles between the biggest WWF superstars!</p>
        </article>
        <article>
          <a href="ppv-royalrumble-89.html" class="image"><img src="../images/rumble-89-index.jpg" alt="" /></a>
          <p>Royal Rumble 1989 unleashes chaos with 30 superstars battling for glory in an unforgettable over-the-top-rope showdown!</p>
        </article>
        <article>
          <a href="ppv-summerslam-88.html" class="image"><img src="../images/slam-88-index.jpg" alt="" /></a>
          <p>SummerSlam 1988 delivers explosive action with iconic matchups, as the WWF's biggest stars collide in the hottest event of the summer!</p>
        </article>
      </div>
    </section>
		-->
    <!-- Section -->
    <!--<section>-->
    <!--  <header class="major">-->
    <!--    <h2>Get in touch</h2>-->
    <!--  </header>-->
    <!--  <p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus, ac varius enim lorem ullamcorper dolore. Proin sed aliquam facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p>-->
    <!--  <ul class="contact">-->
    <!--    <li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li>-->
    <!--    <li class="icon solid fa-phone">(000) 000-0000</li>-->
    <!--    <li class="icon solid fa-home">1234 Somewhere Road #8254<br />-->
    <!--      Nashville, TN 00000-0000</li>-->
    <!--  </ul>-->
    <!--</section>-->
    <!-- Footer -->
    <footer id="footer">
      <p class="copyright">&copy; Integralist. All rights reserved.</p>
      <p class="copyright small">Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>
  </div>
</div>

    </div>
    <!-- Scripts -->
    <script src="../../assets/js/jquery.min.js"></script>
    <script src="../../assets/js/browser.min.js"></script>
    <script src="../../assets/js/breakpoints.min.js"></script>
    <script src="../../assets/js/util.js"></script>
    <script src="../../assets/js/main.js"></script>

		<!-- The following script is for handling the automatic TOC generated by `make build` -->
		<script>
		// Get references to the elements
		const nav = document.querySelector('#main nav');
		const h1 = document.querySelector('#main h1');

		// Move the `nav` element to be underneath the `h1`
		h1.insertAdjacentElement('afterend', nav);

		// Hide the `nav` element by default using inline styles
		nav.style.display = 'none';

		// Create a new `h2` element with the text "TOC"
		const toc = document.createElement('h2');
		toc.textContent = 'TOC';
		toc.className = "toc"

		// Add inline styles to make the `h2` look clickable
		// DISABLED: done with className
		//
		// toc.style.cursor = 'pointer';
		// toc.style.color = 'blue';
		// toc.style.textDecoration = 'underline';

		// Add a click event listener to toggle the visibility of the `nav`
		toc.addEventListener('click', () => {
				nav.style.display = nav.style.display === 'none' ? 'block' : 'none';
		});

		// Insert the `h2` element above the `nav`
		nav.insertAdjacentElement('beforebegin', toc);
		</script>
  </body>
</html>
